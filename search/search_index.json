{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>     FiveAM.dev is a personal space about software: tools, tips, notes... It has been created by @albert-rz, a software engineer based in Barcelona.     </p>"},{"location":"#featured-posts","title":"Featured posts","text":""},{"location":"#users-and-groups-in-linux","title":"Users and groups in Linux","text":"<p>Managing users and groups is an essential task for system administrators, who have to ensure that the system is secure and runs smoothly. This also includes software engineers working with Dockerfiles.</p> <p>In this blog post, we'll cover the basics of user and group management in Linux.</p> <p>Read</p>"},{"location":"#linux-commands-for-process-management","title":"Linux commands for process management","text":"<p>This post covers the fundamentals of Linux process management, which includes monitoring and controlling the processes running on a Linux system. We will discuss how to list processes and jobs, terminate them, and manage the resources they consume.</p> <p>Read</p>"},{"location":"about/","title":"About","text":"<p>Hellooo</p>"},{"location":"articles/process_management/","title":"Linux commands for process management","text":"<p>This post covers the fundamentals of Linux process management, which includes monitoring and controlling the processes running on a Linux system. We will discuss how to list processes and jobs, terminate them, and manage the resources they consume.</p>"},{"location":"articles/process_management/#what-is-a-process-and-a-job","title":"What is a process? And a job?","text":"<p>In Linux, a process refers to an active instance of a program, which is an executable file stored on your machine. Meanwhile, a job is a process that is being managed by the shell and has not yet completed its execution.</p>"},{"location":"articles/process_management/#interactive-vs-non-interactive-processes","title":"Interactive vs. Non-interactive processes","text":"<p>Interactive processes (or user processes) are launched and managed through a terminal session. On the other hand, non-interactive processes (also called automatic or batch processes) are started by the system and are not connected to the terminal.</p>"},{"location":"articles/process_management/#how-are-processes-identified","title":"How are processes identified?","text":"<p>Since Linux is a multi-process and multi-users OS, each process must be uniquely identifed by the kernel.</p> <p>Processes are identified by their Process ID (PID) and their Parent Process ID (PPID). Consequently, processes can be categorized into two types:</p> <ul> <li>Parent processes - They instantiate one or more child processes.</li> <li>Child process - Created by another a parent process during its execution.</li> </ul>"},{"location":"articles/process_management/#find-a-processes-and-its-pid","title":"Find a processes and its PID","text":"<p><code>ps</code> displays information about a specific set of active processes. To continuously update the displayed information and the selected processes, you can use <code>top</code> or <code>htop</code> instead. If you wish to output information about all processes, you can use the <code>ps -A</code> or <code>ps -e</code>:</p> <pre><code>$ ps -A\n  PID TTY          TIME CMD\n    1 ?        00:00:00 docker-init\n    7 ?        00:00:00 sleep\n   17 ?        00:00:00 dockerd\n   45 ?        00:00:00 sshd\n   51 ?        00:00:01 containerd\n 1422 ?        00:00:00 sh\n 1483 ?        00:00:00 sh\n 2117 ?        00:00:00 sh\n 2124 ?        00:00:10 node\n 2152 ?        00:00:14 node\n</code></pre> <p>If we know the name of the process, then we can use <code>pidof</code> to get PID:</p> <pre><code>$ pidof node\n2152 2124\n</code></pre> <p>The output of <code>ps</code> can be formatted:</p> <pre><code>$ ps -Ao pid,ppid,comm\n    1     0 docker-init\n    7     1 sleep\n   17     7 dockerd\n   45     1 sshd\n   51    17 containerd\n 1422     0 sh\n 1483     0 sh\n 2117     0 sh\n 2124  2117 node\n 2152  2124 node\n</code></pre> <p>Format options include: <code>pid</code>, <code>ppid</code>, <code>comm</code></p> <p>Note</p> <p><code>ps</code> accepts several kinds of options:</p> <ul> <li>UNIX options - which may be grouped and must be preceded by a dash</li> <li>BSD options - which may be grouped and must not be used with a dash</li> <li>GNU long options - which are preceded by two dashes</li> </ul> <p>Options of different types may be freely mixed, but conflicts can appear.</p> <p>Some options are equivalent, but not all. For example, <code>ps -Ao</code> and <code>ps axo</code> produce the same result, but <code>ps -aux</code> is distinct from <code>ps aux</code>.</p>"},{"location":"articles/process_management/#run-a-proces-in-background","title":"Run a proces in background","text":"<p>You can run a process in background by appending the &amp; symbol to the command. This will start the process and return control to the terminal immediately.</p> <pre><code>$ command &amp;\n</code></pre> <p>If the command produces any output, it will continue to write to the terminal even while running in the background. To provent this, the output can be redirected to a file or to <code>/dev/null</code>:</p> <pre><code>$ pip install pandas &gt; /dev/null &amp;\n</code></pre> <p>Pressing <code>Ctrl+z</code> can move any process to the background, but be cautious as this action sends the <code>SIGSTOP</code> signal to the process, causing it to pause and the terminal prompt will be returned. </p> <pre><code>$ pip install pandas\nCollecting pandas\n^Z\n[1]+  Stopped                 pip install pandas\n$ jobs\n[1]+  Stopped                 pip install pandas\n</code></pre> <p>At this stage, you have the option to use the <code>bg</code> command to move the paused process to the background, where it will continue running.</p> <pre><code>$ bg\n</code></pre> <p>Alternatively, you can utilize the <code>fg</code> command to bring the paused process to the foreground, allowing it to resume running.</p>"},{"location":"articles/process_management/#states-of-a-process-in-linux","title":"States of a process in Linux","text":"<p>The state of a process signifies its present condition or activity within the operating system. Throughout its execution, a process undergoes transitions between different states depending on its environment and circumstances. Below are the typical states observed in a Linux process:</p> <ul> <li>Running - The process is actively executing and utilizing the CPU.</li> <li>Sleeping (interruptible) - The process is waiting for an event to occur, such as input or a signal. It can be interrupted and resume execution.</li> <li>Sleeping (uninterruptible) - The process is waiting for an event, but it cannot be interrupted. This state is typically associated with critical system operations and device drivers.</li> <li>Stopped - The process has been stopped, usually by receiving a <code>SIGSTOP</code> signal.</li> <li>Zombie - The process has completed its execution but still has an entry in the process table. It exists until its parent process retrieves its exit status.</li> <li>Orphan - The process has been abandoned by its parent process. It will be re-parented to the proces with PID 1.</li> <li>Dead - The process has finished its execution and has been removed from the process table.</li> </ul>"},{"location":"articles/process_management/#todo","title":"TODO","text":"<ul> <li> kill a process</li> <li> send a signal</li> <li> priority</li> <li> renice</li> </ul>"},{"location":"articles/users_groups/","title":"Users and groups in Linux","text":"<p>Managing users and groups is an essential task for system administrators, who have to ensure that the system is secure and runs smoothly. This also includes software engineers working with Dockerfiles.</p> <p>In this post, we'll cover the basics of user and group management in Linux.</p>"},{"location":"articles/users_groups/#current-user","title":"Current user","text":"<p>The <code>whoami</code>, <code>groups</code> and <code>id</code> commands can be used to get information about the current user in Linux.</p> <p><code>whoami</code> simply returns the username of the current user, while <code>groups</code>  displays the names of the groups that the user is a member of:</p> <pre><code>$ whoami\nalbert-rz\n$ groups\nalbert-rz sudo\n</code></pre> <p><code>id</code> provides more detailed information about the current user, including the user ID (UID), group ID (GID), and any supplementary group IDs:</p> <pre><code>$ id\nuid=1000(albert-rz) gid=1000(albert-rz) groups=1000(albert-rz),27(sudo)\n</code></pre>"},{"location":"articles/users_groups/#display-all-users-and-groups","title":"Display all users and groups","text":"<p>Users and groups are saved in the <code>/etc/passwd</code> and <code>/etc/group</code> files, respectively. You can extract this informatino with <code>cut</code>:</p> <pre><code>$ cut -d : -f 1 /etc/passwd\n</code></pre> <p>and:</p> <pre><code>$ cut -d : -f 1 /etc/group\n</code></pre>"},{"location":"articles/users_groups/#add","title":"Add","text":"<p><code>useradd</code> is used to create new user accounts. As an example, The command below will add a new user named \"max\":</p> <pre><code>$ useradd -s /bin/bash -m -G sudo max\n</code></pre> <p>Where:</p> <ul> <li><code>-s /bin/bash</code> - Set <code>/bin/bash</code> as login shell fo the new account.</li> <li><code>-m</code> - Create user's home directory.</li> <li><code>G sudo</code> - Allow the new user to sudo.</li> </ul> <p>The <code>chpasswd</code> command can be used to modify a user's password:</p> <pre><code>$ echo 'max:new_password' | chpasswd\n</code></pre> <p>Finally, we can log in as the new user and access the home directory.</p> <pre><code>$ su - max\n</code></pre> <p>The equivalent command for groups is <code>groupadd</code>.</p>"},{"location":"articles/users_groups/#delete","title":"Delete","text":"<p>Accounts can be deleted with <code>userdel</code>. As an example, the command below will delete a user named \"max\" and the its home directory:</p> <pre><code>$ userdel -r max\n</code></pre> <p>The equivalent command for groups is <code>groupdel</code>.</p>"},{"location":"articles/users_groups/#modify","title":"Modify","text":"<p>After creating an account, <code>usermod</code> enables you to modify the user's home directory, group membership, shell, or login value.</p> <p>The example below demonstrates how to use usermod. First, we create a user named \"max\" along with their home folder and some files.</p> <pre><code>$ useradd -m max\n$ ls -la /home/max\n$ su - max\n$ touch hello.txt\n$ exit\n</code></pre> <p>Then, we change the login value to \"john\", create a new home folder for the user, and transfer their files to it. Finally, we reassign the user to a new group and add it to sudo list.</p> <pre><code>$ usermod -l john -m -d /home/john max\n$ groupadd john\n$ usermod -g john -aG sudo john\n$ ls -la /home/john\ntotal 20\ndrwxr-x--- 2 john john 4096 Mar 18 17:07 .\ndrwxr-xr-x 1 root root 4096 Mar 18 17:08 ..\n-rw-r--r-- 1 john john  220 Jan  6  2022 .bash_logout\n-rw-r--r-- 1 john john 3771 Jan  6  2022 .bashrc\n-rw-r--r-- 1 john john  807 Jan  6  2022 .profile\n-rw-rw-r-- 1 john john    0 Mar 18 17:07 hello.txt\n</code></pre>"}]}